---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import { sidebarLayoutConfig, siteConfig } from "../config";
import localAnimeList from "../data/anime";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";
import MainGridLayout from "../layouts/MainGridLayout.astro";

// i18n helpers with safe fallbacks (avoid TS errors if keys not defined yet)
const T = {
  unknown: i18n((I18nKey as any).animeUnknown ?? "animeUnknown") || "Unknown",
  episodes: i18n((I18nKey as any).animeEpisodes ?? "animeEpisodes") || "episodes",
  paginationFirst: i18n((I18nKey as any).paginationFirst ?? "paginationFirst") || "First",
  paginationLast: i18n((I18nKey as any).paginationLast ?? "paginationLast") || "Last",
  searchAnimePlaceholder:
    i18n((I18nKey as any).searchAnimePlaceholder ?? "searchAnimePlaceholder") ||
    "Search by title, genre, studio...",
};

// æ‰©å±•çŠ¶æ€ç±»å‹ï¼ŒåŒ…å« onholdã€droppedï¼Œè§£å†³ TS æ¯”è¾ƒé”™è¯¯
type LocalAnimeItem = (typeof localAnimeList)[number];
type AnimeStatus = "watching" | "completed" | "planned" | "onhold" | "dropped";
type AnimeItem = Omit<LocalAnimeItem, "status"> & {
  status: AnimeStatus;
  updatedAt?: string;
  // åŸå§‹æ”¾é€å¼€å§‹ + å±•ç¤ºæ—¥æœŸ
  startDate?: string;
  displayDate?: string;
  // æ¨¡æ¿ä½¿ç”¨åˆ°çš„å­—æ®µ
  genre: string[];
  progress?: number;
  totalEpisodes?: number;
  episodes?: string;
};

// é¡µé¢å¼€å…³
if (!siteConfig.featurePages.anime) {
  return Astro.redirect("/404/");
}

// åŒä¾§è¾¹æ 
const isBothSidebarMode = sidebarLayoutConfig.position === "both";

// Bangumi API é…ç½®
const BANGUMI_USER_ID = siteConfig.bangumi?.userId || "your-user-id";
const BANGUMI_API_BASE = "https://api.bgm.tv";
const isValidUserId = !!BANGUMI_USER_ID && BANGUMI_USER_ID !== "your-user-id";

// è·å–æ¨¡å¼ï¼ˆåœ¨ src/config.ts é…ç½®ï¼‰
const ANIME_MODE = siteConfig.anime?.mode || "bangumi";

// å¯é€‰é¡¹ç›®ä¸Šé™ä¸ç¼“å­˜ TTLï¼ˆå°æ—¶ï¼‰- ä½¿ç”¨æœ¬åœ°æ‰©å±•ç±»å‹ä»¥æ¶ˆé™¤ TS æŠ¥é”™
type AnimeConfigExt = { mode?: "bangumi" | "local"; maxItems?: number; cacheTtlHours?: number };
const animeCfg = (siteConfig.anime || {}) as AnimeConfigExt;
const MAX_ITEMS =
  Number(animeCfg.maxItems) > 0 ? Number(animeCfg.maxItems) : Infinity;
const CACHE_TTL_HOURS =
  Number(animeCfg.cacheTtlHours) > 0 ? Number(animeCfg.cacheTtlHours) : 24;

// ç®€æ˜“ç£ç›˜æŒä¹…ç¼“å­˜ï¼ˆNode ç«¯æœ‰æ•ˆï¼‰ï¼›SSR/æ„å»ºæœŸé—´å¤ç”¨ï¼Œæµè§ˆå™¨ç«¯é™é»˜è·³è¿‡
type CacheEntry<T> = { ts: number; data: T };
const isNode = typeof process !== "undefined" && !!(process as any).versions?.node;
let fs: typeof import("fs/promises") | null = null;
let path: typeof import("path") | null = null;
if (isNode) {
  const fsMod = await import("fs/promises");
  const pathMod = await import("path");
  fs = fsMod;
  path = pathMod;
}

const cacheRoot = isNode && path ? path.resolve(process.cwd(), ".cache", "bangumi") : "";

async function diskCacheGet<T>(key: string, ttlHours: number): Promise<T | null> {
  if (!isNode || !fs || !path) return null;
  try {
    await fs.mkdir(cacheRoot, { recursive: true });
    const file = path.resolve(cacheRoot, `${key}.json`);
    const buf = await fs.readFile(file, { encoding: "utf8" as any });
    // å…¼å®¹ç±»å‹æ¨æ–­ä¸ºé string çš„æƒ…å†µï¼ˆå¦‚ NonSharedBufferï¼‰
    const jsonStr =
      typeof buf === "string" ? buf : new TextDecoder("utf-8").decode(buf as unknown as BufferSource);
    const parsed = JSON.parse(jsonStr) as CacheEntry<T>;
    const ageHours = (Date.now() - parsed.ts) / 3.6e6;
    if (ageHours <= ttlHours) return parsed.data;
    return null;
  } catch {
    return null;
  }
}
async function diskCacheSet<T>(key: string, data: T): Promise<void> {
  if (!isNode || !fs || !path) return;
  try {
    await fs.mkdir(cacheRoot, { recursive: true });
    const file = path.resolve(cacheRoot, `${key}.json`);
    const payload: CacheEntry<T> = { ts: Date.now(), data };
    await fs.writeFile(file, JSON.stringify(payload), { encoding: "utf8" });
  } catch {
    // ignore
  }
}

// fetch å¸¦é‡è¯•ä¸ 429/5xx é€€é¿
async function fetchWithRetry(url: string, init?: RequestInit, retries = 4, baseDelayMs = 400): Promise<Response> {
  for (let attempt = 0; attempt <= retries; attempt++) {
    const res = await fetch(url, init).catch(() => null);
    if (res && res.ok) return res as Response;

    // 429 æˆ– 5xx: æŒ‡æ•°é€€é¿ + éšæœºæŠ–åŠ¨ï¼Œä¸”å°Šé‡ Retry-After
    const status = res?.status ?? 0;
    if (attempt < retries && (status === 429 || (status >= 500 && status <= 599))) {
      let delay = baseDelayMs * Math.pow(2, attempt);
      const retryAfter = res?.headers?.get("Retry-After");
      if (retryAfter) {
        const seconds = Number(retryAfter);
        if (!Number.isNaN(seconds) && seconds > 0) delay = seconds * 1000;
      }
      delay += Math.floor(Math.random() * 200); // jitter
      await new Promise((r) => setTimeout(r, delay));
      continue;
    }
    if (res) return res;
    throw new Error("Network error");
  }
  throw new Error("fetchWithRetry exhausted");
}

// å…¼å®¹åœ°ä» infobox/å¤šç§æ¥æºæå–é”®å€¼
function pickFirstUsefulValue(v: any): string | undefined {
  if (v == null) return undefined;
  if (typeof v === "string") return v.trim() || undefined;
  if (Array.isArray(v)) {
    for (const it of v) {
      const got = pickFirstUsefulValue(it);
      if (got) return got;
    }
    return undefined;
  }
  if (typeof v === "object") {
    if (typeof v.v === "string") return v.v.trim() || undefined;
    if (typeof v.value === "string") return v.value.trim() || undefined;
  }
  return undefined;
}

// ä» subject.infobox æå–â€œæ”¾é€å¼€å§‹æ—¶é—´â€
function getStartDateFromInfobox(subject: any): string | undefined {
  const keys = [
    "æ”¾é€å¼€å§‹",
    "æ”¾é€é–‹å§‹",
    "é¦–æ’­",
    "é¦–æ˜ ",
    "é¦–æ’­æ—¥æœŸ",
    "ä¸Šæ˜ æ—¥æœŸ",
    "ä¸Šæ˜ å¹´åº¦",
    "ä¸Šæ˜ æ—¶é—´",
    "å‘å”®æ—¥",
    "é–‹å§‹",
    "é–‹å§‹æ—¥",
    "å¼€å§‹",
    "é–‹å§‹æ™‚é–“",
    "å¼€å§‹æ—¶é—´",
    "å¼€æ’­",
    "é¦–æ’­æ—¶é—´",
  ];
  const infobox = subject?.infobox;
  if (!Array.isArray(infobox)) return undefined;

  for (const k of keys) {
    const entry = infobox.find((x: any) => x?.key === k);
    if (!entry) continue;
    const v = pickFirstUsefulValue(entry?.value);
    if (v) return v;
  }
  return undefined;
}

// ä» subject.infobox æå–â€œåŠ¨ç”»åˆ¶ä½œ/åˆ¶ä½œ/Studioâ€ç­‰ï¼ˆæ¯”äººå‘˜æ›´å¯é ï¼‰
function getStudioFromInfobox(subject: any): string | undefined {
  const keys = ["åŠ¨ç”»åˆ¶ä½œ", "è£½ä½œ", "åˆ¶ä½œ", "åŠ¨ç”»å…¬å¸", "Studio", "åˆ¶ä½œå…¬å¸", "åˆ¶ä½œã‚¹ã‚¿ã‚¸ã‚ª"];
  const infobox = subject?.infobox;
  if (!Array.isArray(infobox)) return undefined;

  for (const k of keys) {
    const entry = infobox.find((x: any) => x?.key === k);
    if (!entry) continue;
    const v = pickFirstUsefulValue(entry?.value);
    if (v) return v;
  }
  return undefined;
}

// å±•ç¤ºæ—¥æœŸï¼šä¼˜å…ˆ YYYY-MM-DDï¼Œå…¶æ¬¡ YYYY-MMï¼Œå†æ¬¡ YYYY
function toDisplayYearOrYearMonth(input?: string): string {
  if (!input) return T.unknown;
  const s = input.trim();
  const ymd = /^(\d{4})-(\d{2})-(\d{2})$/;
  const ym = /^(\d{4})-(\d{2})$/;
  const y = /^(\d{4})$/;
  if (ymd.test(s)) return s;
  if (ym.test(s)) return s;
  if (y.test(s)) return s;

  const mYMD = s.match(/(\d{4})[-/å¹´](\d{1,2})[-/æœˆ](\d{1,2})/);
  if (mYMD) {
    const year = mYMD[1];
    const mm = String(mYMD[2]).padStart(2, "0");
    const dd = String(mYMD[3]).padStart(2, "0");
    return `${year}-${mm}-${dd}`;
  }
  const mYM = s.match(/(\d{4})[-/å¹´](\d{1,2})/);
  if (mYM) {
    const year = mYM[1];
    const mm = String(mYM[2]).padStart(2, "0");
    return `${year}-${mm}`;
  }
  const mY = s.match(/(\d{4})/);
  if (mY) return mY[1];

  return T.unknown;
}

// å®‰å…¨è§£ææ—¥æœŸä¸ºæ—¶é—´æˆ³ï¼ˆæ”¯æŒ YYYY / YYYY-MM / YYYY-MM-DDï¼‰
function toTime(input?: string) {
  if (!input) return 0;
  const s = input.trim();
  if (/^\d{4}$/.test(s)) return Date.parse(`${s}-01-01T00:00:00Z`);
  if (/^\d{4}-\d{2}$/.test(s)) return Date.parse(`${s}-01T00:00:00Z`);
  const t = Date.parse(s);
  return Number.isNaN(t) ? 0 : t;
}

// è·å–å•ä¸ªæ¡ç›®ç›¸å…³äººå‘˜ä¿¡æ¯ï¼ˆç¼“å­˜ + é€€é¿ï¼‰
async function fetchSubjectPersonsRaw(subjectId: number) {
  const res = await fetchWithRetry(`${BANGUMI_API_BASE}/v0/subjects/${subjectId}/persons`);
  const data = await res.json();
  return Array.isArray(data) ? data : [];
}
async function fetchSubjectDetailRaw(subjectId: number) {
  const res = await fetchWithRetry(`${BANGUMI_API_BASE}/v0/subjects/${subjectId}`);
  if (!res.ok) throw new Error(`Bangumi subject ${subjectId} error: ${res.status}`);
  return await res.json();
}

// ç®€å•å†…å­˜ç¼“å­˜ + ç£ç›˜ç¼“å­˜
const subjectDetailCache = new Map<number, any>();
const subjectPersonsCache = new Map<number, any[]>();

async function fetchSubjectDetailCached(id: number) {
  if (subjectDetailCache.has(id)) return subjectDetailCache.get(id);
  const diskKey = `subject-${id}`;
  const disk = await diskCacheGet<any>(diskKey, CACHE_TTL_HOURS);
  if (disk) {
    subjectDetailCache.set(id, disk);
    return disk;
  }
  const d = await fetchSubjectDetailRaw(id).catch((e) => {
    console.error(`Error fetching subject ${id} detail:`, e);
    return null;
  });
  subjectDetailCache.set(id, d);
  if (d) await diskCacheSet(diskKey, d);
  return d;
}
async function fetchSubjectPersonsCached(id: number) {
  if (subjectPersonsCache.has(id)) return subjectPersonsCache.get(id);
  const diskKey = `persons-${id}`;
  const disk = await diskCacheGet<any[]>(diskKey, CACHE_TTL_HOURS);
  if (disk) {
    subjectPersonsCache.set(id, disk);
    return disk;
  }
  const p = await fetchSubjectPersonsRaw(id).catch((e) => {
    console.error(`Error fetching subject ${id} persons:`, e);
    return [];
  });
  subjectPersonsCache.set(id, p);
  if (p?.length) await diskCacheSet(diskKey, p);
  return p;
}

// å¹¶å‘é™åˆ¶
async function mapWithConcurrency<T, R>(
  items: T[],
  limit: number,
  fn: (item: T, idx: number) => Promise<R>,
): Promise<R[]> {
  const results: R[] = new Array(items.length);
  let i = 0;
  const runners = new Array(Math.min(limit, items.length)).fill(0).map(async () => {
    while (true) {
      const idx = i++;
      if (idx >= items.length) return;
      results[idx] = await fn(items[idx], idx);
    }
  });
  await Promise.all(runners);
  return results;
}

// è·å– Bangumi æ”¶è—åˆ—è¡¨ï¼ˆåˆ†é¡µæŠ“å– + å¯é€‰é¡¹ç›®ä¸Šé™ + ç£ç›˜æŒä¹…ç¼“å­˜ï¼‰
async function fetchBangumiCollection(userId: string, subjectType: number, type: number) {
  const cacheKey = `collection-${userId}-${subjectType}-${type}`;
  const cached = await diskCacheGet<{ data: any[] }>(cacheKey, CACHE_TTL_HOURS);
  if (cached && cached.data?.length) return cached;

  try {
    let allData: any[] = [];
    let offset = 0;
    const pageLimit = 50;

    while (true) {
      const url = `${BANGUMI_API_BASE}/v0/users/${userId}/collections?subject_type=${subjectType}&type=${type}&limit=${pageLimit}&offset=${offset}`;
      const response = await fetchWithRetry(url);
      if (!response.ok) throw new Error(`Bangumi API error: ${response.status}`);

      const data = await response.json();
      const batch = data.data || [];
      if (batch.length > 0) allData = [...allData, ...batch];

      if (allData.length >= MAX_ITEMS) {
        allData = allData.slice(0, MAX_ITEMS as number);
        break;
      }

      const hasMore = batch.length === pageLimit;
      if (!hasMore) break;
      offset += pageLimit;

      await new Promise((resolve) => setTimeout(resolve, 100)); // èŠ‚æµ
    }

    const payload = { data: allData };
    await diskCacheSet(cacheKey, payload);
    return payload;
  } catch (error) {
    console.error("Error fetching Bangumi data:", error);
    return null;
  }
}

// è½¬æ¢ä¸ºé¡µé¢æ•°æ®
async function processBangumiData(data: any, status: AnimeStatus): Promise<AnimeItem[]> {
  if (!data || !data.data) return [];
  const items: any[] = data.data;

  const detailedItems = await mapWithConcurrency(items, 6, async (item: any) => {
    const subjectId = item.subject_id;
    const subject = item.subject || {};

    // å…ˆå°è¯• subject è‡ªå¸¦çš„ dateï¼Œå¦åˆ™ detail/infobox å…œåº•
    const rawDate = (subject?.date || "").trim();
    const isUnknown = !rawDate || /^unknown$/i.test(rawDate) || rawDate === "0000-00-00";
    let startDate: string | undefined = rawDate || undefined;

    if (isUnknown) {
      const detail = await fetchSubjectDetailCached(subjectId);
      const detailDate = (detail?.date || "").trim();
      const infoboxStart = getStartDateFromInfobox(detail);
      const candidate = detailDate || infoboxStart || "";
      startDate = candidate || undefined;
    }

    const displayDate = toDisplayYearOrYearMonth(startDate);

    const rating = typeof item.rate === "number" ? Number(item.rate.toFixed(1)) : 0;
    const progress = item.ep_status || 0;
    const totalEpisodes =
      typeof subject?.eps === "number" && subject?.eps > 0 ? subject.eps : progress;

    // Studio ä¼˜å…ˆä» infobox å–ï¼›æ²¡æœ‰å†å›é€€åˆ°äººå‘˜
    let studio = getStudioFromInfobox(subject) || T.unknown;
    if (!studio || studio === T.unknown) {
      const subjectPersons = await fetchSubjectPersonsCached(subjectId);
      if (Array.isArray(subjectPersons)) {
        const priorities = ["åŠ¨ç”»åˆ¶ä½œ", "è£½ä½œ", "åˆ¶ä½œ"];
        for (const relation of priorities) {
          const match = subjectPersons.find((person) => person.relation === relation);
          if (match?.name) {
            studio = match.name;
            break;
          }
        }
      }
      if (!studio) studio = T.unknown;
    }

    const genre: string[] = Array.isArray(subject?.tags)
      ? subject.tags
          .slice(0, 4)
          .map((t: any) => {
            if (typeof t === "string") return t.trim();
            if (t && typeof t.name === "string") return t.name.trim();
            return "";
          })
          .filter(Boolean)
      : [];

    const updatedAt: string | undefined =
      item.updated_at || item.comment_updated_at || item.created_at || subject?.date || undefined;

    const cover = subject?.images?.medium || "/assets/anime/default.webp";
    const title = subject?.name_cn || subject?.name || T.unknown;

    return {
      title,
      status,
      rating,
      cover,
      description: (subject?.short_summary || subject?.name_cn || "").trimStart(),
      year: displayDate,
      displayDate,
      studio,
      link: `https://bgm.tv/subject/${subjectId}`, // å§‹ç»ˆä½¿ç”¨ subjectId å…œåº•
      progress,
      totalEpisodes,
      startDate: startDate || "",
      endDate: "",
      updatedAt,
      genre,
      episodes: `${totalEpisodes || 0} ${T.episodes}`,
    } as AnimeItem;
  });

  return detailedItems as AnimeItem[];
}

// æ ¹æ®æ¨¡å¼è·å–ç•ªå‰§åˆ—è¡¨
let animeList: AnimeItem[] = [];
if (ANIME_MODE === "local") {
  animeList = (localAnimeList as AnimeItem[]).map((a) => ({
    ...a,
    displayDate: toDisplayYearOrYearMonth(a.startDate || a.year),
    genre: Array.isArray((a as any).genre) ? (a as any).genre : [],
    episodes: `${(a.totalEpisodes as any) || 0} ${T.episodes}`,
    link: `https://bgm.tv/subject/${(a as any).id || (a as any).subjectId || ""}`,
  }));
} else if (!isValidUserId) {
  animeList = [];
} else {
  const [watchingData, plannedData, completedData, onHoldData, droppedData] = await Promise.all([
    fetchBangumiCollection(BANGUMI_USER_ID, 2, 3),
    fetchBangumiCollection(BANGUMI_USER_ID, 2, 1),
    fetchBangumiCollection(BANGUMI_USER_ID, 2, 2),
    fetchBangumiCollection(BANGUMI_USER_ID, 2, 4),
    fetchBangumiCollection(BANGUMI_USER_ID, 2, 5),
  ]);

  const watchingList = watchingData ? await processBangumiData(watchingData, "watching") : [];
  const plannedList = plannedData ? await processBangumiData(plannedData, "planned") : [];
  const completedList = completedData ? await processBangumiData(completedData, "completed") : [];
  const onHoldList = onHoldData ? await processBangumiData(onHoldData, "onhold") : [];
  const droppedList = droppedData ? await processBangumiData(droppedData, "dropped") : [];

  animeList = [...watchingList, ...plannedList, ...completedList, ...onHoldList, ...droppedList];
  if (Number.isFinite(MAX_ITEMS)) {
    animeList = animeList.slice(0, MAX_ITEMS as number);
  }
}

// è·å–çŠ¶æ€çš„ç¿»è¯‘æ–‡æœ¬å’Œæ ·å¼
function getStatusInfo(status: string) {
  switch (status) {
    case "watching":
      return {
        text: i18n(I18nKey.animeStatusWatching),
        class: "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300",
        icon: "â–¶",
      };
    case "completed":
      return {
        text: i18n(I18nKey.animeStatusCompleted),
        class: "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300",
        icon: "âœ“",
      };
    case "planned":
      return {
        text: i18n(I18nKey.animeStatusPlanned),
        class: "bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-300",
        icon: "â°",
      };
    case "onhold":
      return {
        text: i18n(I18nKey.animeStatusOnHold),
        class: "bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-300",
        icon: "â¸",
      };
    case "dropped":
      return {
        text: i18n(I18nKey.animeStatusDropped),
        class: "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-300",
        icon: "âœ—",
      };
    default:
      return {
        text: status,
        class: "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300",
        icon: "?",
      };
  }
}

// ç»Ÿè®¡
const stats = {
  total: animeList.length,
  watching: animeList.filter((anime) => anime.status === "watching").length,
  completed: animeList.filter((anime) => anime.status === "completed").length,
  avgRating: (() => {
    const ratedAnime = animeList.filter((anime) => (anime.rating || 0) > 0);
    if (ratedAnime.length === 0) return "0.0";
    return (
      ratedAnime.reduce((sum, anime) => sum + (anime.rating || 0), 0) / ratedAnime.length
    ).toFixed(1);
  })(),
};

// æœ€åæ›´æ–°æ—¶é—´
const lastUpdated = new Date().toLocaleString("zh-CN", {
  year: "numeric",
  month: "2-digit",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
  hour12: false,
  timeZone: "Asia/Shanghai",
});

// æ’åº
const sortedAnimeList = [...animeList].sort((a, b) => {
  const aTime = toTime(a.updatedAt) || toTime(a.startDate) || toTime(a.displayDate);
  const bTime = toTime(b.updatedAt) || toTime(b.startDate) || toTime(b.displayDate);
  return bTime - aTime;
});

// æ ‡è®°ä¸ºå·²è¯»é¿å…æœªä½¿ç”¨å‘Šè­¦
void animeList;
void stats;
void lastUpdated;
void sortedAnimeList;
void isBothSidebarMode;
---

<MainGridLayout title={i18n(I18nKey.anime)} description={i18n(I18nKey.animeSubtitle)}>
  <div class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32">
    <div class="card-base z-10 px-9 py-6 relative w-full">
      <!-- é¡µé¢æ ‡é¢˜ -->
      <div class="relative w-full mb-8">
        <div class="mb-6">
          <h1 class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2 relative
                    before:w-1 before:h-8 before:rounded-md before:bg-[var(--primary)]
                    before:absolute before:top-1/2 before:-translate-y-1/2 before:-left-4">
            {i18n(I18nKey.animeTitle)}
          </h1>
          <p class="text-black/75 dark:text-white/75">{i18n(I18nKey.animeSubtitle)}</p>
        </div>
        
        <!-- ç»Ÿè®¡ä¿¡æ¯å¡ç‰‡ -->
        <div class="stats-container grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
          <div class="stat-card bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] p-4 flex flex-col items-center justify-center">
            <div class="text-xs text-black/60 dark:text-white/60 mb-1">æ€»æ•°</div>
            <div class="text-2xl font-bold text-[var(--primary)]">{stats.total}</div>
          </div>
          <div class="stat-card bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] p-4 flex flex-col items-center justify-center">
            <div class="text-xs text-black/60 dark:text-white/60 mb-1">ç»¼åˆè¯„åˆ†</div>
            <div class="text-2xl font-bold text-blue-500">{stats.avgRating}</div>
          </div>
          <div class="stat-card bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] p-4 flex flex-col items-center justify-center">
            <div class="text-xs text-black/60 dark:text-white/60 mb-1">æœ€åæ›´æ–°æ—¶é—´</div>
            <div class="text-sm font-medium text-black/80 dark:text-white/80">{lastUpdated}</div>
          </div>
        </div>
        
        <!-- æœç´¢æ¡† -->
        <div class="search-container mb-6">
          <div class="relative">
            <input 
              type="text" 
              id="search-input" 
              placeholder={T.searchAnimePlaceholder}
              class="w-full px-4 py-3 pl-12 rounded-[var(--radius-large)] border border-[var(--line-divider)] bg-[var(--card-bg)] text-[var(--text-body)] focus:outline-none focus:ring-2 focus:ring-[var(--primary)] focus:border-transparent"
            />
            <div class="absolute left-4 top-1/2 transform -translate-y-1/2 text-[var(--text-secondary)]">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
              </svg>
            </div>
          </div>
        </div>
        
        <!-- è¿‡æ»¤æŒ‰é’® -->
        <div class="mb-6">
          <div class="filter-container flex flex-wrap gap-2">
            <button class="filter-tag active" data-status="all">
              {i18n(I18nKey.animeFilterAll)} 
              <span class="ml-1 bg-[var(--primary)] text-white text-xs rounded-full px-2 py-0.5">({animeList.length})</span>
            </button>
            <button class="filter-tag" data-status="watching">
              {i18n(I18nKey.animeStatusWatching)} 
              <span class="ml-1 bg-green-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'watching').length})</span>
            </button>
            <button class="filter-tag" data-status="planned">
              {i18n(I18nKey.animeStatusPlanned)} 
              <span class="ml-1 bg-amber-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'planned').length})</span>
            </button>
            <button class="filter-tag" data-status="completed">
              {i18n(I18nKey.animeStatusCompleted)} 
              <span class="ml-1 bg-blue-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'completed').length})</span>
            </button>
            {ANIME_MODE === 'bangumi' && (
              <>
                <button class="filter-tag" data-status="onhold">
                  {i18n(I18nKey.animeStatusOnHold)} 
                  <span class="ml-1 bg-purple-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'onhold').length})</span>
                </button>
                <button class="filter-tag" data-status="dropped">
                  {i18n(I18nKey.animeStatusDropped)} 
                  <span class="ml-1 bg-red-500 text-white text-xs rounded-full px-2 py-0.5">({animeList.filter(a => a.status === 'dropped').length})</span>
                </button>
              </>
            )}
          </div>
        </div>
      </div>

      <!-- åŠ¨æ¼«åˆ—è¡¨ -->
      <div class="mb-8">
        {ANIME_MODE !== 'local' && !isValidUserId ? (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ˜¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
              {i18n(I18nKey.animeEmpty)}
            </h3>
            <p class="text-black/60 dark:text-white/60">
              è¯·åœ¨ src/config.ts æ–‡ä»¶ä¸­è®¾ç½®ä½ çš„ Bangumi ç”¨æˆ·ID
            </p>
          </div>
        ) : animeList.length > 0 ? (
          <div id="anime-list-container" class={`anime-grid-container gap-4 md:gap-6 list-mode ${isBothSidebarMode ? "both-sidebar" : "single-sidebar"}`}>
            {sortedAnimeList.map(anime => {
              const statusInfo = getStatusInfo(anime.status);
              const total = typeof anime.totalEpisodes === 'number' ? anime.totalEpisodes : 0;
              const progress = typeof anime.progress === 'number' ? anime.progress : 0;
              const progressPercent = total > 0 ? (progress / total) * 100 : 0;
              
              return (
                <div
                  class="group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden transition-all duration-300 hover:shadow-lg hover:scale-[1.02]"
                  data-anime-status={anime.status}
                  data-anime-title={String(anime.title || '').toLowerCase()}
                  data-anime-studio={String(anime.studio || '').toLowerCase()}
                  data-anime-genre={(anime.genre || []).map(g => String(g || '').toLowerCase()).join(' ')}
                >
                  <!-- å°é¢åŒºåŸŸ -->
                  <div class="relative aspect-[2/3] overflow-hidden">
                    <a href={anime.link} target="_blank" rel="noopener noreferrer" class="block w-full h-full">
                      <ImageWrapper 
                        src={anime.cover} 
                        alt={anime.title}
                        class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110"
                      />
                      <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                        <div class="absolute inset-0 flex items-center justify-center">
                          <div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
                            <svg class="w-6 h-6 text-gray-800 ml-1" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                              <path d="M8 5v14l11-7z"/>
                            </svg>
                          </div>
                        </div>
                      </div>
                    </a>
                    
                    <!-- çŠ¶æ€æ ‡ç­¾ -->
                    <div class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}`}>
                      <span class="mr-1">{statusInfo.icon}</span>
                      <span>{statusInfo.text}</span>
                    </div>
                    
                    <!-- è¯„åˆ† -->
                    <div class="absolute top-2 right-2">
                      <div class="bg-black/70 text-white rounded-[6px] border border-white/20 shadow-sm inline-flex items-center gap-1 px-2 py-1">
                        <svg class="w-4 h-4 text-yellow-400" fill="currentColor" viewBox="0 0 20 20" aria-hidden="true">
                          <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                        </svg>
                        <span class="text-[10px] font-semibold leading-none">{anime.rating}</span>
                      </div>
                    </div>
                    
                    <!-- è¿›åº¦æ¡ -->
                    {anime.status === 'watching' && (
                      <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-2">
                        <div class="w-full bg-white/20 rounded-full h-1.5 mb-1">
                          <div class="bg-gradient-to-r from-emerald-400 to-teal-400 h-1.5 rounded-full transition-all duration-300" style={`width: ${progressPercent}%`}></div>
                        </div>
                        <div class="text-white text-xs font-medium">
                          {progress}/{total} ({Math.round(progressPercent)}%)
                        </div>
                      </div>
                    )}
                  </div>
                  
                  <!-- å†…å®¹ -->
                  <div class="p-3">
                    <h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 line-clamp-2 leading-tight">{anime.title}</h3>
                    <p class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2">{anime.description}</p>
                    
                    <div class="space-y-1 text-xs">
                      <div class="flex justify-between">
                        <span class="text-black/50 dark:text-white/50">{i18n(I18nKey.animeYear)}</span>
                        <span class="text-black/70 dark:text-white/70">{anime.displayDate}</span>
                      </div>
                      <div class="flex justify-between">
                        <span class="text-black/50 dark:text-white/50">{i18n(I18nKey.animeStudio)}</span>
                        <span class="text-black/70 dark:text-white/70 truncate ml-2">{anime.studio}</span>
                      </div>
                      <div class="flex flex-wrap gap-1 mt-2">
                        {(anime.genre || []).map(g => (
                          <span class="px-1.5 py-0.5 bg-[var(--btn-regular-bg)] text-black/70 dark:text-white/70 rounded text-xs">{g}</span>
                        ))}
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        ) : (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ˜¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
              {i18n(I18nKey.animeEmpty)}
            </h3>
            <p class="text-black/60 dark:text-white/60">
              {ANIME_MODE === 'local' ? i18n(I18nKey.animeEmptyLocal) : i18n(I18nKey.animeEmptyBangumi)}
            </p>
          </div>
        )}
      </div>
      
      <!-- åˆ†é¡µæ§ä»¶ -->
      <div id="pagination-container" class="pagination-container flex justify-center items-center gap-2 mt-8">
        <button id="first-page" class="pagination-btn px-3 py-2 rounded-md bg-[var(--btn-regular-bg)] text-[var(--btn-content)] border border-[var(--line-divider)] disabled:opacity-50 disabled:cursor-not-allowed">
          Â« {T.paginationFirst}
        </button>
        <button id="prev-page" class="pagination-btn px-3 py-2 rounded-md bg-[var(--btn-regular-bg)] text-[var(--btn-content)] border border-[var(--line-divider)] disabled:opacity-50 disabled:cursor-not-allowed">
          &lt; {i18n(I18nKey.prevPage)}
        </button>
        <div id="page-numbers" class="flex gap-1"></div>
        <button id="next-page" class="pagination-btn px-3 py-2 rounded-md bg-[var(--btn-regular-bg)] text-[var(--btn-content)] border border-[var(--line-divider)] disabled:opacity-50 disabled:cursor-not-allowed">
          {i18n(I18nKey.nextPage)} &gt;
        </button>
        <button id="last-page" class="pagination-btn px-3 py-2 rounded-md bg-[var(--btn-regular-bg)] text-[var(--btn-content)] border border-[var(--line-divider)] disabled:opacity-50 disabled:cursor-not-allowed">
          {T.paginationLast} Â»
        </button>
      </div>
    </div>
  </div>

  <script is:inline define:vars={{ isBothSidebarMode }}>
  // å¸ƒå±€åˆ‡æ¢åŠ¨ç”»ï¼ˆä¿æŒåŸé€»è¾‘ï¼‰
  (function() {
    setTimeout(() => {
      const animeListContainer = document.getElementById("anime-list-container");
      if (!animeListContainer) {
        console.debug("anime-list-container not found, skipping layout initialization");
        return;
      }

      if (typeof window.layoutManager !== 'undefined') {
        window.layoutManager.init(isBothSidebarMode);
        const currentLayout = window.layoutManager.getLayout();
        updateAnimeListLayout(currentLayout);
        window.layoutManager.checkScreenSizeAndAdjust();
      } else {
        setTimeout(() => {
          if (typeof window.layoutManager !== 'undefined') {
            window.layoutManager.init(isBothSidebarMode);
            const currentLayout = window.layoutManager.getLayout();
            updateAnimeListLayout(currentLayout);
            window.layoutManager.checkScreenSizeAndAdjust();
          }
        }, 300);
      }
    }, 50);

    function updateAnimeListLayout(layout) {
      const animeListContainer = document.getElementById("anime-list-container");
      if (!animeListContainer) return;

      const animeItems = Array.from(document.querySelectorAll('[data-anime-status]'));
      const firstPositions = new Map();
      animeItems.forEach(item => {
        const rect = item.getBoundingClientRect();
        firstPositions.set(item, {
          left: rect.left,
          top: rect.top,
          width: rect.width,
          height: rect.height
        });
      });
      
      animeListContainer.classList.remove("list-mode", "grid-mode");
      if (layout === "grid") {
        animeListContainer.classList.add("grid-mode");
        const rightSidebar = document.querySelector('.right-sidebar-container');
        if (rightSidebar) {
          rightSidebar.style.display = 'none';
          rightSidebar.classList.add('hidden-in-grid-mode');
        }
        const mainGrid = document.getElementById('main-grid');
        if (mainGrid) {
          mainGrid.style.gridTemplateColumns = '17.5rem 1fr';
          mainGrid.classList.add('two-column-layout');
          mainGrid.setAttribute('data-layout-mode', 'grid');
        }
      } else {
        animeListContainer.classList.add("list-mode");
        const rightSidebar = document.querySelector('.right-sidebar-container');
        if (rightSidebar) {
          rightSidebar.style.display = '';
          rightSidebar.classList.remove('hidden-in-grid-mode');
        }
        const mainGrid = document.getElementById('main-grid');
        if (mainGrid) {
          mainGrid.style.gridTemplateColumns = '';
          mainGrid.classList.remove('two-column-layout');
          mainGrid.setAttribute('data-layout-mode', 'list');
        }
      }

      requestAnimationFrame(() => {
        const lastPositions = new Map();
        animeItems.forEach(item => {
          const rect = item.getBoundingClientRect();
          lastPositions.set(item, {
            left: rect.left,
            top: rect.top
          });
        });
        
        animeItems.forEach(item => {
          const first = firstPositions.get(item);
          const last = lastPositions.get(item);
          if (first && last) {
            const deltaX = first.left - last.left;
            const deltaY = first.top - last.top;
            item.style.transition = 'none';
            item.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
          }
        });
        
        requestAnimationFrame(() => {
          animeItems.forEach((item, index) => {
            setTimeout(() => {
              item.classList.add('anime-animating');
              item.style.transition = '';
              item.style.transform = '';
            }, index * 20);
          });
          
          setTimeout(() => {
            animeItems.forEach(item => {
              item.classList.remove('anime-animating');
              item.style.transition = '';
              item.style.transform = '';
            });
          }, 500 + animeItems.length * 20);
        });
      });
    }

    window.addEventListener("layoutChange", (event) => {
      updateAnimeListLayout(event.detail.layout);
      // è®©åˆ†é¡µé€»è¾‘åœ¨å¸ƒå±€æ”¹å˜ååˆ·æ–°æ¯é¡µæ•°é‡
      if (window.__animePage && window.__animePage.updateAfterLayout) {
        window.__animePage.updateAfterLayout();
      }
    });
  })();
</script>

  <style>
    /* å­—ä½“ä¸å®¹å™¨ */
    :root { --anime-font: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', system-ui, -apple-system, 'Segoe UI', Roboto, 'Noto Sans SC', 'Segoe UI Emoji', 'Apple Color Emoji', sans-serif; }
    html.dark { --anime-font: 'Noto Sans SC', 'Hiragino Sans GB', 'PingFang SC', 'Microsoft YaHei UI', system-ui, -apple-system, 'Segoe UI', Roboto, 'Segoe UI Emoji', 'Apple Color Emoji', sans-serif; }
    body, h1, h2, h3, h4, h5, h6, p, span, div, button, input, textarea, select, a { font-family: var(--anime-font) !important; }
    .card-base { container-type: inline-size; }
    
    /* å¸ƒå±€å›ºå®šåˆ—æ•° */
    .anime-grid-container { transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
    .anime-grid-container.grid-mode { display: grid; grid-template-columns: repeat(5, 1fr); }
    .anime-grid-container.list-mode { display: grid; grid-template-columns: repeat(4, 1fr); }
    
    .filter-container { display: flex; flex-wrap: wrap; gap: 0.5rem; }
    .filter-tag {
      padding: 0.5rem 1rem; border: 1px solid var(--line-divider); border-radius: var(--radius-large);
      background: var(--btn-regular-bg); color: var(--btn-content);
      font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease; white-space: nowrap; display: flex; align-items: center;
    }
    .filter-tag:hover:not(.active) { background: var(--btn-hover-bg); border-color: var(--primary); transform: translateY(-1px); }
    .filter-tag.active { background: var(--primary); color: white; border-color: var(--primary); }
    .filter-tag.active:hover { background: var(--primary) !important; color: white !important; border-color: var(--primary) !important; transform: translateY(-1px); }
    
    /* å¡ç‰‡åŠ¨ç”»ä¸æ‚¬æµ® */
    [data-anime-status] { transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
    #anime-list-container.grid-mode [data-anime-status]:hover {
      transform: translateY(-8px) scale(1.02);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15);
      z-index: 10; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    #anime-list-container.list-mode [data-anime-status]:hover {
      transform: translateX(8px) scale(1.01);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
      z-index: 10; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* ç»Ÿä¸€å¯è§æ€§ï¼šä»…é€šè¿‡ç±»æ§åˆ¶ */
    [data-anime-status].is-filtered-out,
    [data-anime-status].is-searched-out,
    [data-anime-status].is-paginated-out { display: none !important; }
    [data-anime-status].anime-animating {
      transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }
    [data-anime-status].anime-fade-in { opacity: 0; transform: scale(0.8); }
    [data-anime-status].anime-fade-in-active { opacity: 1; transform: scale(1); }
    [data-anime-status].anime-fade-out { opacity: 0; transform: scale(0.95); transition: opacity 0.3s ease, transform 0.3s ease; }
    
    .stats-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }
    .stat-card { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem; text-align: center; }
    
    .pagination-container { margin-top: 2rem; display: flex; justify-content: center; align-items: center; gap: 0.5rem; }
    .pagination-btn {
      padding: 0.5rem 1rem; border: 1px solid var(--line-divider); border-radius: var(--radius-large);
      background: var(--btn-regular-bg); color: var(--btn-content);
      font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.25rem;
    }
    .pagination-btn:hover:not(:disabled) { background: var(--btn-hover-bg); border-color: var(--primary); }
    .pagination-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .page-number {
      padding: 0.5rem 0.75rem; border: 1px solid var(--line-divider); border-radius: var(--radius-large);
      background: var(--btn-regular-bg); color: var(--btn-content);
      font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease;
    }
    .page-number:hover { background: var(--btn-hover-bg); border-color: var(--primary); }
    .page-number.active { background: var(--primary); color: white; border-color: var(--primary); }
    
    .search-container { position: relative; margin-bottom: 1.5rem; }
    #search-input { padding-left: 2.5rem; transition: all 0.3s ease; }
    #search-input:focus { box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2); }
    .search-highlight { background-color: #fef3c7; padding: 0.125rem 0.25rem; border-radius: 0.25rem; font-weight: 600; }

    /* ç§»åŠ¨ç«¯ï¼ˆAndroid/å°å±ï¼‰è§†è§‰ä¼˜åŒ– */
    @media (max-width: 640px) {
      .anime-grid-container.grid-mode { grid-template-columns: repeat(2, 1fr); }
      .anime-grid-container.list-mode { grid-template-columns: repeat(2, 1fr); }

      .group .p-3 { padding: 0.875rem; }
      .group h3 { font-size: 1rem; line-height: 1.5; }
      .group p { font-size: 0.9375rem; line-height: 1.6; }

      .filter-tag { padding: 0.625rem 1rem; font-size: 1rem; }
      .pagination-btn, .page-number { padding: 0.625rem 0.875rem; font-size: 1rem; }

      #search-input { padding: 0.875rem 1rem 0.875rem 2.75rem; font-size: 1rem; }
    }
  </style>

  <!-- å•ä¸€ init + teardownï¼ŒSwup ç”Ÿå‘½å‘¨æœŸå®‰å…¨é‡ç»‘ï¼ˆæ”¹ä¸ºçº¯ JSï¼‰ -->
  <script is:inline>
    (function() {
      // æä¾›å…¨å±€å‘½åç©ºé—´ä»¥ä¾¿å…¶ä»–è„šæœ¬è§¦å‘åˆ·æ–°
      window.__animePage = window.__animePage || {};

      function initAnimePage() {
        const state = {
          currentPage: 1,
          pageWindowStart: 1,
          windowSize: 5,
          itemsPerPage: 10,
          listeners: [],
          searchDebounce: 0,
        };

        const container = document.getElementById('anime-list-container');
        const allItems = Array.from(document.querySelectorAll('[data-anime-status]'));
        const filterTags = Array.from(document.querySelectorAll('.filter-tag'));
        const searchInput = document.getElementById('search-input');
        const pageNumbersContainer = document.getElementById('page-numbers');
        const firstBtn = document.getElementById('first-page');
        const prevBtn = document.getElementById('prev-page');
        const nextBtn = document.getElementById('next-page');
        const lastBtn = document.getElementById('last-page');

        function getItemsPerPageByLayout() {
          const isListMode = container && container.classList.contains('list-mode');
          const isPC = window.matchMedia('(min-width: 768px)').matches;
          return (isListMode && isPC) ? 8 : 10;
        }

        // è®¡ç®—è¿‡æ»¤ + æœç´¢ç»“æœ
        function computeFiltered() {
          const activeStatusEl = document.querySelector('.filter-tag.active');
          const activeStatus = (activeStatusEl && activeStatusEl.getAttribute('data-status')) || 'all';
          const term = ((searchInput && searchInput.value) || '').trim().toLowerCase();

          return allItems.filter((item) => {
            const itemStatus = item.getAttribute('data-anime-status') || '';
            const byStatus = (activeStatus === 'all') || (itemStatus === activeStatus);

            if (!term) return byStatus;

            const title = item.getAttribute('data-anime-title') || '';
            const studio = item.getAttribute('data-anime-studio') || '';
            const genre = item.getAttribute('data-anime-genre') || '';
            const matches = title.includes(term) || studio.includes(term) || genre.includes(term) || itemStatus.includes(term);
            return byStatus && matches;
          });
        }

        function flipAnimate(keep, show, hide) {
          const first = new Map();
          [...keep, ...show].forEach((el) => {
            const rect = el.getBoundingClientRect();
            first.set(el, { left: rect.left, top: rect.top });
          });

          hide.forEach((el) => el.classList.add('anime-fade-out'));

          setTimeout(() => {
            hide.forEach((el) => {
              el.classList.add('is-filtered-out');
              el.classList.remove('anime-fade-out');
            });

            show.forEach((el) => {
              el.classList.remove('is-filtered-out', 'is-searched-out');
              el.classList.add('anime-fade-in');
              el.style.opacity = '0';
              el.style.transform = 'scale(0.8)';
              el.style.transition = 'none';
            });

            requestAnimationFrame(() => {
              const last = new Map();
              [...keep, ...show].forEach((el) => {
                const rect = el.getBoundingClientRect();
                last.set(el, { left: rect.left, top: rect.top });
              });

              keep.forEach((el) => {
                const a = first.get(el);
                const b = last.get(el);
                if (a && b) {
                  const dx = a.left - b.left;
                  const dy = a.top - b.top;
                  el.style.transition = 'none';
                  el.style.transform = `translate(${dx}px, ${dy}px)`;
                }
              });

              requestAnimationFrame(() => {
                const all = [...keep, ...show];
                all.forEach((el, i) => {
                  setTimeout(() => {
                    el.classList.add('anime-animating');
                    if (keep.includes(el)) {
                      el.style.transition = '';
                      el.style.transform = '';
                    }
                    if (show.includes(el)) {
                      el.classList.remove('anime-fade-in');
                      el.classList.add('anime-fade-in-active');
                      el.style.transition = '';
                      el.style.opacity = '1';
                      el.style.transform = 'scale(1)';
                    }
                  }, i * 20);
                });

                setTimeout(() => {
                  all.forEach((el) => {
                    el.classList.remove('anime-animating', 'anime-fade-in-active');
                    el.style.transition = '';
                    el.style.transform = '';
                    el.style.opacity = '';
                  });
                }, 500 + all.length * 20);
              });
            });
          }, 200);
        }

        function updatePaginationUI(totalItems) {
          state.itemsPerPage = getItemsPerPageByLayout();
          const totalPages = Math.ceil(totalItems / state.itemsPerPage);

          pageNumbersContainer.innerHTML = '';
          if (totalPages === 0) {
            state.currentPage = 1;
            state.pageWindowStart = 1;
          } else {
            if (state.currentPage > totalPages) state.currentPage = totalPages;
            const maxStart = Math.max(1, totalPages - state.windowSize + 1);
            if (state.pageWindowStart > maxStart) state.pageWindowStart = maxStart;
            if (state.pageWindowStart < 1) state.pageWindowStart = 1;
          }

          const end = Math.min(totalPages, state.pageWindowStart + state.windowSize - 1);
          for (let i = state.pageWindowStart; i <= end; i++) {
            const btn = document.createElement('button');
            btn.textContent = String(i);
            btn.classList.add('page-number');
            if (i === state.currentPage) btn.classList.add('active');
            btn.addEventListener('click', () => {
              state.currentPage = i;
              applyPagination();
              updatePaginationUI(totalItems);
            });
            pageNumbersContainer.appendChild(btn);
          }

          const onFirst = state.currentPage === 1 || totalPages === 0;
          const onLast = state.currentPage === totalPages || totalPages === 0;
          firstBtn.disabled = onFirst;
          prevBtn.disabled = onFirst;
          nextBtn.disabled = onLast;
          lastBtn.disabled = onLast;
        }

        function applyPagination() {
          const filtered = computeFiltered();
          state.itemsPerPage = getItemsPerPageByLayout();

          const startIndex = (state.currentPage - 1) * state.itemsPerPage;
          const endIndex = startIndex + state.itemsPerPage;

          const showSet = new Set(filtered.slice(startIndex, endIndex));
          allItems.forEach((el) => {
            if (showSet.has(el)) el.classList.remove('is-paginated-out');
            else el.classList.add('is-paginated-out');
          });
        }

        function refreshAll(triggerFLIP = false) {
          const beforeVisible = allItems.filter(el => !el.classList.contains('is-filtered-out') && !el.classList.contains('is-searched-out'));
          // å…ˆåŸºäºè¿‡æ»¤å’Œæœç´¢è®¾ç½® is-filtered-out/is-searched-out
          const activeStatusEl = document.querySelector('.filter-tag.active');
          const activeStatus = (activeStatusEl && activeStatusEl.getAttribute('data-status')) || 'all';
          const term = ((searchInput && searchInput.value) || '').trim().toLowerCase();
          const matched = new Set(computeFiltered());

          allItems.forEach((el) => {
            const inFilter = (activeStatus === 'all') || (el.getAttribute('data-anime-status') === activeStatus);
            const inSearch = !term || matched.has(el);
            if (inFilter && inSearch) {
              el.classList.remove('is-filtered-out', 'is-searched-out');
            } else {
              if (!inFilter) el.classList.add('is-filtered-out'); else el.classList.remove('is-filtered-out');
              if (!inSearch) el.classList.add('is-searched-out'); else el.classList.remove('is-searched-out');
            }
          });

          // åˆ·æ–°åˆ†é¡µ
          const filteredNow = allItems.filter(el => !el.classList.contains('is-filtered-out') && !el.classList.contains('is-searched-out'));
          state.currentPage = 1;
          state.pageWindowStart = 1;
          applyPagination();
          updatePaginationUI(filteredNow.length);

          if (triggerFLIP) {
            const afterVisible = allItems.filter(el => !el.classList.contains('is-filtered-out') && !el.classList.contains('is-searched-out'));
            const keep = afterVisible.filter(el => beforeVisible.includes(el));
            const show = afterVisible.filter(el => !beforeVisible.includes(el));
            const hide = beforeVisible.filter(el => !afterVisible.includes(el));
            flipAnimate(keep, show, hide);
          }
        }

        // ç»‘å®šè¿‡æ»¤æŒ‰é’®
        filterTags.forEach(tag => {
          const handler = () => {
            if (tag.classList.contains('active')) return;
            filterTags.forEach(t => t.classList.remove('active'));
            tag.classList.add('active');
            refreshAll(true);
          };
          tag.addEventListener('click', handler);
          state.listeners.push({ el: tag, type: 'click', handler });
        });

        // æœç´¢è¾“å…¥
        if (searchInput) {
          const handler = function() {
            clearTimeout(state.searchDebounce);
            state.searchDebounce = setTimeout(() => refreshAll(false), 300);
          };
          searchInput.addEventListener('input', handler);
          state.listeners.push({ el: searchInput, type: 'input', handler });
        }

        // åˆ†é¡µæŒ‰é’®
        if (firstBtn && prevBtn && nextBtn && lastBtn) {
          const firstH = () => {
            const totalPages = Math.ceil(computeFiltered().length / getItemsPerPageByLayout());
            if (state.currentPage !== 1 && totalPages > 0) {
              state.currentPage = 1; state.pageWindowStart = 1;
              applyPagination(); updatePaginationUI(computeFiltered().length);
            }
          };
          const prevH = () => {
            if (state.currentPage > 1) {
              state.currentPage--; state.pageWindowStart = Math.max(1, state.pageWindowStart - 1);
              applyPagination(); updatePaginationUI(computeFiltered().length);
            }
          };
          const nextH = () => {
            const totalPages = Math.ceil(computeFiltered().length / getItemsPerPageByLayout());
            if (state.currentPage < totalPages) {
              state.currentPage++; const maxStart = Math.max(1, totalPages - state.windowSize + 1);
              state.pageWindowStart = Math.min(maxStart, state.pageWindowStart + 1);
              applyPagination(); updatePaginationUI(computeFiltered().length);
            }
          };
          const lastH = () => {
            const totalPages = Math.ceil(computeFiltered().length / getItemsPerPageByLayout());
            if (totalPages > 0 && state.currentPage !== totalPages) {
              state.currentPage = totalPages; state.pageWindowStart = Math.max(1, totalPages - state.windowSize + 1);
              applyPagination(); updatePaginationUI(computeFiltered().length);
            }
          };
          firstBtn.addEventListener('click', firstH);
          prevBtn.addEventListener('click', prevH);
          nextBtn.addEventListener('click', nextH);
          lastBtn.addEventListener('click', lastH);
          state.listeners.push({ el: firstBtn, type: 'click', handler: firstH });
          state.listeners.push({ el: prevBtn, type: 'click', handler: prevH });
          state.listeners.push({ el: nextBtn, type: 'click', handler: nextH });
          state.listeners.push({ el: lastBtn, type: 'click', handler: lastH });
        }

        // åˆæ¬¡æ¸²æŸ“
        refreshAll(false);

        // åœ¨å¸ƒå±€å˜åŒ–æ—¶åˆ·æ–°æ¯é¡µæ•°é‡+åˆ†é¡µ
        function updateAfterLayout() {
          applyPagination();
          updatePaginationUI(computeFiltered().length);
        }
        window.__animePage.updateAfterLayout = updateAfterLayout;

        // Teardown
        function cleanup() {
          state.listeners.forEach(({ el, type, handler }) => el.removeEventListener(type, handler));
          state.listeners = [];
          clearTimeout(state.searchDebounce);
          delete window.__animePage.updateAfterLayout;
        }
        window.__animePage.cleanup = cleanup;
      }

      // Swup ç”Ÿå‘½å‘¨æœŸ
      function swupBind() {
        if (!window.swup) return;
        const reinit = () => {
          if (window.__animePage && window.__animePage.cleanup) window.__animePage.cleanup();
          setTimeout(() => {
            initAnimePage();
          }, 50);
        };
        window.swup.hooks.on('content:replace', reinit);
        window.swup.hooks.on('page:view', reinit);
        window.swup.hooks.on('animation:in:end', reinit);
      }

      // æ™®é€šåŠ è½½
      document.addEventListener('DOMContentLoaded', () => {
        initAnimePage();
        if (window.swup) swupBind();
      });

      // å¦‚æœç¨åå¯ç”¨ swup
      document.addEventListener('swup:enable', () => {
        if (window.__animePage && window.__animePage.cleanup) window.__animePage.cleanup();
        initAnimePage();
        swupBind();
      });
    })();
  </script>
</MainGridLayout>
